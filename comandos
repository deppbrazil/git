# PASTA DE INICIALIZAÇÃO #

// Windows
btn direto no gitBash > propriedades > iniciar em > colocar caminho

// Mac - alias
criar arquivo .bash_profile e dentro dele colocar:
alias myapps='cd /caminho/do/seu/htdocs'

// Ou para o terminal já iniciar na pasta colocar dentro do .bash_profile
cd /caminho/desejado/

*myapps é só um exemplo, você pode usar qualquer nome para o seu alias
depois chamar o 'alias' no terminal

--------------------------------------------------

# CHAVES SSH #

// No terminal colocar:
ssh-keygen

// Pressione enter

// Gerar senha se quiser

// Se não + enter

// Vai gerar caminho da chave gerada (geralmente cria na pasta de perfil de usuário)

// Abrir pasta com as chaves

// Abrir o id_rsa.pub com bloco de notas e copiar o código

// No gitHub/bitbucket em account settings > ssh keys > add ssh keys > colocar título + key > add

// Confirmar com senha do gitHub

--------------------------------------------------

# INICIALIZACAO DO REPOSITORIO LOCAL #

// Mais utilizada
git init 
(inicia um .git para gerenciamento de versao)

// Aconselhado usar com equipes em server remoto do tipo bare
git init --bare 
(inicia repositorio .git em modo bare)

--------------------------------------------------

# APARECER PASTA .GIT #

// Windows
painel de controle > aparência e personalização >
opções de pasta > modo de exibição > pastas e arq. ocultos >
mostrar arquivos, pastas e unidades ocultas.

// Mac 
defaults write com.apple.Finder AppleShowAllFiles TRUE
defaults write com.apple.Finder AppleShowAllFiles FALSE

--------------------------------------------------

# BÁSICOS PARA INICIO DE PROJETO #

cd nome da pasta  
(entrar nas pastas e subpastas)

cd ..  
(voltar um nível)

cd .. Pasta1/Pasta2/Pasta3 
(vai entrar em Pasta1/Pasta2/Pasta3)

clear  
(limpar terminal)

git status  
(informa o estatus do projeto e se tem algo a ser commitado)

git add nome do arq.  
(isso add arq. ao stage área)

git reset HEAD nome do arquivo.extensao 
(sai do stage area e volta ele pro repositório local)

git add '*.txt'  
(adicionar todos arquivos txt ao stage área)

git add .  
(adicionar todos os arquivos de todas extensões ao stage área)

git checkout -- nomeDoArquivo.extensão 
(volta ao estado do commit da branch master)

git rm nome do arquivo 
(deleta arquivos sem volta)

git diff 
(mostra quais alterações que foram feitas no arquivo antes de ir para stage área)

git diff --staged 
(mostra quais alterções foram feitas no arquivo que foi adicionado ao stage área)

--------------------------------------------------

# GITIGNORE #

// Ignorar arquivos no controle do git
criar um arq com extensão .gitignore e dentro dele colocar nome e extenção do arquivo que não quer ser controlado, ou ate mesmo uma pasta, sendo 1 por linha.

*Ex:
// Dentro do arq. do .gitignore
Linha 1 = .gitignore 
(vai ignorar o próprio arq. .gitignore)

Linha 2 = nomedoaquivo.txt 
(vai ignorar o arq. .txt)

Linha 3 = temp/ 
(a barra no final indica diretório, ou seja, uma pasta)

// Quando voce der um git status nao vai aparecer os arquivos mencionados dentro do .gitignore

--------------------------------------------------

# BRANCHS #

// Default (branch master)

git branch teste  
(joga uma cópia da branch master na branch teste)

git checkout teste  
(entra na branch teste)

git checkout -b teste 
(cria a branch teste com base na master e ja entra dentro)

git checkout master 
(volta para branch master)

git merge teste  
(faz o merge - *importante estar dentro da master)

git branch -d teste  
(deleta branch teste)

--------------------------------------------------

# TAGS #

git tag -a v1.0 -m "Versão 1.0"
(cria uma tag anotada (-a) do último commit)

git tag -a v1.0 (colar aqui chave do commit) -m "Versão 1.0"  
(cria tag anotada para um commit específico com base na chave)

git tag  
(lista tags)

git show v1.0  
(mostrar detalhes específicos sobre a tag)

git checkout v1.0  
(vai para versão v1.0 do projeto)

git checout master  
(volta para branch master)

git tag -d v1.0  
(deletar tag criada)

--------------------------------------------------

# COMMITS #

git commit -m "mensagem do commit"
(commitar o projeto com mensagem)

git commit -a -m "mensagem do commit"
(pula a etapa de add ao stage e commita direto)

git checkout -- nome do aquivo  
(voltar o arq. original do ultimo commit)

git rm nome do arq. 
(deleta o arquivo sem volta, e resolve conflito no stage em caso de remoção dos arq. do último commit)

git log  
(histórico de commit com hora + usuário)

git log -p 
(histórico detalhado dos commits)

git log -p -1  
(último commit detalhado)

git log --pretty=oneline  
(mostar a chave de cada commit e a mensagem)

gitk  
(abre interface gráfica)

git commit --amend -m "novo nome do commit"  
(substitui último commit feito com o commit atual)

git push origin nomeDaTag
// Ou
git push --tags
(envia tags pro remoto) 

git pull
(puxar as tags)

--------------------------------------------------

# CONFLITOS #

// Quando criamos uma branch teste com base na master e fazemos alterações e commitamos, e logo após entramos na branch master fazemos alterações também e commitamos, ao dar o merge na branch master isso trará alguns conflitos, que ao abrir o arquivo alterado ele trará os commits da branch teste + commit da branch master, teremos entao que resolver esses conflitos na mão e logo após fazer um novo commit.

--------------------------------------------------

# REPOSITÓRIOS REMOTOS #

git remote 
(lista repositórios adicionados)

// Por padrao ele ira retornar origin, pois é o repositório de origem

git push origin master 
(vai enviar seu projeto da branch master commitado ao repositorio remoto origin)

git pull origin master 
(puxa atualizações do remoto)

git fetch origin branch + [o nome da branch] 
(com isso ele puxa do repositório remoto e joga dentro da branch)

--------------------------------------------------

# REPOSITORIO REMOTO EM MAQUINA VITUAL #

// Com servidor local em maquina virtual rodando windowns

// Dentro da pasta do repositório server criar pasta "projetos1"

// Agora vamos dar acesso a essa pasta via rede

// Ver nome da máquina em painel de controle > sistema e segurança > sistema

// Ai abrir configurações de sistema

// Depois va em: proteção do sistema > nome do computador > nome completo do computador : vmserver (nome da máquina como servidor remoto)

// Ou pode ser acesso por ip também

// Agora botão direito na pasta projetos criada > compartilhar com > pessoas específicas > todos > adicionar > permissão: leitura e gravação > compartilhar

// Se for agora na sua máquina e colocar > na barra de url em meu computador > digitar \\vmserver > enter > agora vai aparecer a pasta projetos dentro do repositório em rede, isso fez um acesso via rede a esta pasta

// *EX: dentro da pasta projetos criar "cliente1" essa sera a pasta a ser trabalhada e compartilhada em equipe

// Instalar o git na máquina do servidor

// Entrar na pasta "cliente1" e iniciar o git init --bare 
(vai criar um monte de pastas pois o repositorio foi iniciado em modo "bare")

// git init 
(repositorio pardão não aconselhado quando se trabalha com equipes)

// git init --bare
(mais aconselhado quando se trabalha em equipe)

// Voltando para o pc de desenvolvimento

// Primeiro acesso no terminal exige essa config.: 
git clone file:////vmserver/projetos/cliente1

// Isso vai clonar o que esta no servidor remoto e trazer para sua máquina local na pasta atual

// Caso voce queira mudar o nome da pasta clonada adicionar nome no final ficando assim:
git clone file:////vmserver/projetos/cliente1 prjrede1

// Isso vai clonar dentro da pasta prjrede1 todos os arq. do servidor remoto

// Na sua pasta local colocar arq. base dos sistema add e commitar

// Porém os arq. ainda não estao no servidor remoto

// Se clonar novamente com nome prjrede2, irá clonar o projeto vázio

// Para enviar o commit do prjrede1 para o servidor remoto sera necessário o push

// Para isso precisa saber o nome do remote, com:
git remote 
(e ele vai retornar [origin])

// Por padrão ele coloca o nome do remote como origin

// Entao para enviar o commit da máquina prjrede1 para o servidor remoto, fazer:
git push origin master 
(git envia os arq. para o servidor origin que estão na branch master)

< Aguardar... >

// Testar agora os arquivos enviado ao servidor remoto, note que se voce entra na pasta do servidor elas vao aparecer diferentes do repositorio da máquina, porque sua estrutura de pastas é diferente estão em modo --bare, os arquivos enviados estarao dentro de "objects"

--------------------------------------------------

# GITHUB #
// Criar repositorio no GitHub:
settings> resositores > new > nome do repositório + descrição > escolher publico ou privado 
[privado somente conta paga] > em seguida voce escolhe se voce quer um arq. readme e um arq. .gitignore > create repositore > pronto foi criado com sucesso


// Volte para o terminal

// Em clone or download e escolher clone com ssh (mais adequado)

// No terminal colocar git clone e colar a conexão ssh

// Se pedir dar yes pra confirmar

// Entrar na pasta com cd e nome da pasta

// Confirme com git status para ver se criou o .git na pasta

// Note que na pasta local foi adicionado o repositório do git + arquivo README.md

// Coloque os arquivo nas pasta depois add e commita com uma msg

// Agora enviar para o repositório do git com:
git push origin master

// Para puxar esse repositório em outra pasta na máquina fazer mesmo procedimento de clonar o repositorio do git por ssh

// Após commmitado e enviado para o git de outras maquinas puxar atualizacao nas estacoes de trabalho com:
git pull origin master

// Pronto

--------------------------------------------------

# OPENSOURCE #

// Colaborar com projetos openSource no GitHub

// Procurar projeto desejado e dar um fork, isso vai trazer uma cópia do projeto ao seu repositório do GitHub

// Depois clonar pra sua máquina local via ssh

// Fazer alterações de colaboração

// Add e commita

// Mandar para o seu repositório no GitHub com: 
git push origin master

// Agora mandar para o proprietário

// Clicar em:
pull requeste > new pull request > escolher a branch se quiser > create pull request

// Colocar título da requisição e colocar comentário da colaboração que voce fez 

// Depois
send pull request

// Pronto foi enviado para o autor para aprovação

// Para o autor vai aparecer esse pull request

// O autor tem a opção de fazer um merge de contribuições que mandaram no pull request

// Da proxima vez que alguém clonar esse projeto vai com as alterações aprovadas pelo autor.

{FIM...}


